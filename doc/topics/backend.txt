.. _topics/backend:

==============
Backend System
==============

Cubane provides a backend system that allows content authors to manage content
very effectively and easily. Various components are integrating themselves into
the backend system, such as the content management system or the media system.

However, you can also use Cubane's backend system without any other components
on its own if you require a quick and effective way to build a backend system
for your data.

Of course Django provides an excellent admin interface by itself, which can be
used instead or beside Cubane's admin interface. However, when it comes to
managing content management data or media assets, those components will not
integrate with Django's admin interface automatically in the way they integrate
with Cubane's backend system.




.. _topics/backend/install:

Installing Cubane's backend system
==================================

First, you need to list the backend system in Django's
:settings:`INSTALLED_APPS`. We use Cubane's :meth:`add_apps()` helper method in
the following example:

.. code-block:: python

    env.add_apps([
        'cubane',
        'cubane.backend',
        ...
        'myApp'
    ])

The backend system also provides a way to manage user accounts. If you would
like to use this component, you need to load ``cubane.backend.accounts`` as
well:

.. code-block:: python

    env.add_apps([
        'cubane',
        'cubane.backend',
        'cubane.backend.accounts',
        ...
        'myApp'
    ])

Finally, your ``urls.py`` file needs to attach the backend to the url structure
of your application. A typical ``urls.py`` file for a CMS-enabled website may
look like this:

.. code-block:: python

    from django.conf.urls import url, include
    from django.contrib.sitemaps import views as sitemaps_views
    from cubane.backend.views import Backend
    from cubane.cms.views import get_cms
    from cubane.urls import *
    from cubane import views as cubane_views

    backend = Backend()
    cms = get_cms()

    setup_default_urls(__name__)

    urlpatterns += [
        # admin
        url(r'^admin/', include(backend.urls)),

        # sitemap and robots
        url(r'^sitemap\.xml$', sitemaps_views.sitemap, {'sitemaps': cms.sitemaps}),
        url(r'^robots\.txt$', cubane_views.robots_txt),

        # cms
        url(r'^', include(cms.urls)),
    ]


Please note that we are creating a new instance of the backend system here and
then attaching it to the url structure of our application. And that's it. You
now have Cubane's backend system available via the following
URL: ``http://localhost:8000/admin/``.

.. note::

    In :settings:`DEBUG` mode, after installing a new Cubane application, the
    default username and password for the backend system are:

    .. parsed-literal::

        Username: admin
        Password: password

    You will be required to change your password after the first login.



.. _topics/backend/customise:

Customising model views
=======================

The following sections will cover various aspects of the backend system
section, in particular how to build your own components within the backend
system.

.. seealso::

    If you are only interested in customising the appearance and behaviour of
    your models that are already listed within the backend system, then please
    refer to section :ref:`Model View Options
    <topics/backend/model_view_options>`.




.. _topics/backend/sections:

Backend Sections
================

Cubane's backend system is using a strict two-level hierarchy for its
navigation system. The first level of navigation usually correlates to a
specific area of interest, such as content items, settings, media assets,
enquiries or accounts. Each section is represented by a backend section, each
can have multiple sub-sections.

For example, the content management system is creating a backend section called
``Content`` and then creates a separate sub-section for each content type that
is used by the system, such as ``Page``, ``Case Studies`` or ``Projects``.

Most of Cubane's sub-systems, such as Cubane's CMS system will automatically
populate various sections based on model classes declared by your application.
However, you may create your own backend sections in order to add your own
functionality to the backend.

In the following example, we will add a new section to the backend system which
shall manage books. In order to install a backend section within the backend
system, declare the following function in your app's ``__init__.py`` file:

.. code-block:: python

    def install_backend(backend):
        from myApp.backend import BookShopBackendSection
        backend.register_section(BookShopBackendSection())

Of course you would need to create your own implementation for a backend
section first. In the example above, we implemented our backend section
``MyBackendSection`` in the file ``myApp.backend.py`` in the following way:

.. code-block:: python

    from cubane.backend.views import BackendSection

    class BookShopBackendSection(BackendSection):
        title = 'Book Shop'
        sections = [
            BooksBackendSection(),
            ...
        ]

The ``title`` field declares the visual name of the section as it is presented
within the backend system, which is ``Book Shop`` in our case.

.. note::

    We placed our implementation for ``BookShopBackendSection`` in the file
    ``backend.py`` for arbitrary reasons. There is no strict requirement on
    where your implementation and extensions for the backend system should live.

Next, we declare a list of sub-sections to be listed within the ``Book Shop``
section, which is ``BooksBackendSection``, which is implemented in a very
similar way to the ``Book Shop`` section itself:

.. code-block:: python

    class BooksBackendSection(BackendSection):
        title = 'Books'
        view = BookView

The main difference is that the sub-section does not declare any further
sub-sections but declares a view instead. A view is a class that has been
derived from :class:`cubane.views.View`. In most cases you would want to derive
your view class from :class:`cubane.views.ModelView` since it provides a lot of
model-related management capabilities with it, such as listing, searching and
filtering records as well as the usual create, edit and delete actions.

However, we will start by looking at it's base class first, which is
:class:`cubane.views.View`:




.. _topics/backend/view:

View
====

A :class:`~cubane.views.View` encapsulates django's url patterns (which you
would usually declare within a ``urls.py`` file) together with view handlers
(which would usually go into a separate ``views.py`` file). Let's look at an
example first:

.. code-block:: python

    from django.shortcuts import get_object_or_404, render
    from cubane.views import View, view, view_url
    from models import Book

    class BookView(View):
        patterns = [
            view_url(r'books/',             'index'),
            view_url(r'books/(?P<pk>\d+)/', 'book')
        ]

        @view(require_GET)
        def index(self, request):
            return render(request, 'index.html', {
                'books': Book.objects.all()
            })

        @view(require_GET)
        def book(self, request, pk):
            book = get_object_or_404(Book, pk=pk)
            return render(request, 'book.html', {
                'book': book
            })

You declare url patterns via the ``patterns`` field, which is a list of url
patterns very similar to how you would declare url patterns within a
``urls.py`` file: The first argument to :func:`~cubane.views.view_url` declares
the regular expression of the url pattern, the second argument gives the name
of the view handler as the name of any method of the same class as a string.

Other than that, the implementation behaves in exactly the same way as a
regular django view handler. You can add decorators, but you need to use the
:func:`~cubane.views.view` function in order to do so as shown in the code
example above.

The benefit from combining multiple endpoints into a :class:`~cubane.views.View`
is that more complex views can be build by deriving from an already existing
view.

You can use a view fully independently of Cubane's backend system (which is why
it is not bundled within the namespace ``cubane.backend``), but the concept of
a :class:`~cubane.views.View` was originally created in order to facilitate
Cubane's backend system to begin with.

You can hook up any number of views within your ``urls.py`` file in the
following way:

.. code-block:: python

    from django.conf.urls import url, include
    from views import BookView

    books = BooksView()

    urlpatterns = [
        url(r'^books/', include(books.urls))
    ]


A view may implement *before* and *after* actions. These are code
implementations that are executed *before* or *after* any other view handler
method of the :class:`~cubane.views.View` is executed:

.. code-block:: python

    class BookView(View):
        def before(self, request, handler):
            print('before')


        def after(self, request, handler, response):
            print('after')


        def index(request):
            print('index')


If you executed the index method of the view, then you should see the following
debug output in your console window:

.. parsed-literal::

    before
    index
    after

Which represents the order in which those method are executed by the system.
Before any view handler method is executed, the ``before`` method is executed.
Then the actual view handler method is executed (in this case ``index``) and
finally after the view handler method returned, the ``after`` method is
executed.

The ``handler`` method refers to the actual view handler method that is
currently executed. The ``response`` argument of the ``after`` method refers to
the response object that has been returned by executing the view handler method.

Both methods, ``before`` and ``after`` may return a response object, in which
case the response of the entire request is the response that was returned. If
nothing is returned (``None``), then the system will simply return the result
of the view handler, which is usually the result of rendering a template.

If the ``before`` handler returns a response object, then the actual view
handler method is never executed.

The ``after`` method may return a response object, in which case the returned
response object replaces any response that was previously returned by the view
handler method.




.. _topics/backend/template_view:

Template View
=============

The previous example defined a :class:`~cubane.views.View` class for presenting
books. Each view handler was using Django's :func:`~django.shortcuts.render`
method for rendering a template. Cubane provides a simple decorator for
rendering a template via a decorator:

.. code-block:: python

    from django.shortcuts import get_object_or_404, render
    from cubane.views import View, view, view_url
    from cubane.decorators import template
    from models import Book

    class BookView(View):
        patterns = [
            view_url(r'books/',             'index'),
            view_url(r'books/(?P<pk>\d+)/', 'book')
        ]

        @view(require_GET)
        @view(template('index.html'))
        def index(self, request):
            return {
                'books': Book.objects.all()
            }

        @view(require_GET)
        @view(template('book.html'))
        def book(self, request, pk):
            book = get_object_or_404(Book, pk=pk)
            return {
                'book': book
            }

By using the :func:`~cubane.decorators.template` decorator, we can specify the
template that is used to render any particular view in a more declarative way.
The view simply returns the template context as a dictionary which then becomes
the template context when rendering the corresponding template file.

Please note how the name of the view method (for example ``index``) correlates
with the name of the template file (``index.html``). This is on purpose for
this example, but there is no rule that this has to be this way; neither the
less, this is very common practice when declaring view handlers.

For this reason, Cubane provides a :class:`cubane.views.TemplateView` class
that is internally derived from :class:`cubane.views.View` and makes use of the
commonly found correlation between the method name and the name of the template
file:

.. code-block:: python

    from django.shortcuts import get_object_or_404, render
    from cubane.views import TemplateView, view, view_url
    from models import Book

    class BookView(TemplateView):
        patterns = [
            view_url(r'books/',             'index'),
            view_url(r'books/(?P<pk>\d+)/', 'book')
        ]

        @view(require_GET)
        def index(self, request):
            return {
                'books': Book.objects.all()
            }

        @view(require_GET)
        def book(self, request, pk):
            book = get_object_or_404(Book, pk=pk)
            return {
                'book': book
            }

This example demonstrates the use of a :class:`cubane.views.TemplateView`. By
deriving the class from :class:`~cubane.views.TemplateView` instead of
:class:`~cubane.views.View`, the system will automatically render the template
file which name is derived from the corresponding method name.

Because the name of the index method is ``index``, the system will
automatically render the template ``index.html``.

You may want to prefix all templates with a specific path, which can be declared
in the following way:

.. code-block:: python

    class BookView(TemplateView):
        template_path = 'myApp/books/'

        ...

``template_path`` declares the path to the template files that are used by the
:class:`~cubane.views.TemplateView` class. In this example, the index method
would render to template ``myApp/books/index.html``.

Internally this behavior is implemented by overriding the ``after`` method of
the :class:`~cubane.views.View` class. If you happened to override the ``after``
method as well, please make sure to call the derived implementation in order to
keep the default behavior of the :class:`~cubane.views.TemplateView`, if this
is what you wanted:

.. code-block:: python

    class BookView(TemplateView):
        def after(self, request, handler, response):
            # TODO: Insert your code here for example
            return super(BookView, self).after(request, handler, response)

The :class:`~cubane.views.TemplateView` class also provides a mechanism to
inject specific render context information for every request:

.. code-block:: python

    class BookView(TemplateView):
        context = {
            'page_title': 'Books'
        }

When rendering any view handler method of the ``BookView`` class, the template
context declared as ``context`` is always part of the resulting template
context that is used to render a template.

Be aware that the context will override any template information that is
returned by a view handler method. If the ``index`` method would return a
dictionary containing ``page_title``, then such value would always be
overridden by the general context that has been declared for the entire
template view class.




.. _topics/backend/api_view:

API View
========

Sometimes a set of view handlers are concerned about generating JSON responses.
We can imagine a JSON-based service endpoint that is concerned about books,
where each view handler will return JSON-encoded data.

For these circumstances, Cubane provides the class
:class:`~cubane.views.ApiView` which will exactly provided this functionality
as the next example demonstrates:

.. code-block:: python

    from django.shortcuts import get_object_or_404, render
    from cubane.views import ApiView, view, view_url
    from models import Book

    class BookApiView(ApiView):
        patterns = [
            view_url(r'books/',             'index'),
            view_url(r'books/(?P<pk>\d+)/', 'book')
        ]

        @view(require_GET)
        def index(self, request):
            return {
                'books': Book.objects.all()
            }

        @view(require_GET)
        def book(self, request, pk):
            book = get_object_or_404(Book, pk=pk)
            return {
                'book': book
            }

The only difference from the previous example is the fact that we derived from
:class:`~cubane.views.ApiView` and not from
:class:`~cubane.views.TemplateView`.

While :class:`~cubane.views.TemplateView` will render a particular template
file, :class:`~cubane.views.ApiView` will simply take the result returned from
a view handler method and encodes it into JSON. Encoded JSON is then packed
into an HTTP response object with the content encoding ``text/javascript``.




.. _topics/backend/model_view:

Model View
==========

A :class:`~cubane.views.ModelView` is derived from
:class:`~cubane.views.TemplateView` and forms the basis for most views as part
of the backend system.

A model view provides a wast amount of functionality for a particular model:

- Multi-column listing of model instances
- Create, Update, Duplicate, Delete
- Sequential Ordering
- Sorting, Searching and Filtering
- Folders and Drag'n Drop

Let's look at a simply example, where we derive our own class from
:class:`~cubane.views.ModelView` in order to provide backend functionality for
managing books:

.. code-block:: python

    from cubane.backend.views import BackendSection
    from cubane.views import ModelView
    from models import Book

    class BookView(ModelView):
        template_path = 'cubane/backend/'
        model = Book

    class BooksBackendSection(BackendSection):
        title = 'Books'
        view = BookView

    class BookShopBackendSection(BackendSection):
        title = 'Book Shop'
        sections = [
            BooksBackendSection()
        ]

The example above links all parts together: It declares a new top-level backend
section ``BookShopBackendSection`` with the name ``Book Shop`` that contains
one sub-section ``BooksBackendSection`` with the name ``Books`` which then
presents a model view ``BookView`` which operates on the ``Book`` model.

.. note::

    For most entities you do not necessarily have to declare this structure by
    yourself. For example, if you derived any models from
    :class:`cubane.cms.models.Entity` then Cubane's CMS component will
    automatically generate appropriate backend views for you.

Of course the presentation and functionality of a
:class:`~cubane.views.ModelView` can be customized and extended. This section
will provide more information on extending the :class:`~cubane.views.ModelView`
itself.

However, the behavior of a :class:`~cubane.views.ModelView` is also driven by
the model itself, since under most circumstances we are not involved in
customizing the :class:`~cubane.views.ModelView` directly.

.. seealso::

    Please refer to the :ref:`Model View Options
    <topics/backend/model_view_options>` section for more information on how to
    control the presentation of a :class:`~cubane.views.ModelView` by declaring
    backend-specific options through the corresponding model class.




.. _topics/backend/model_view_form:

Model View Form
===============

A model view provides rich edit capabilities. In order to edit a model
instance, the corresponding model view needs to know what form to use for this
purpose. A form can be either declared by the model itself or the model view.

In the later case, the form that is used for editing model instance can be
declared via the ``from`` declaration on the model view class as the following
example demonstrates:

.. code-block:: python

    from cubane.views import ModelView
    from models import Book
    from forms import BookForm

    class BookView(ModelView):
        template_path = 'cubane/backend/'
        model = Book
        form = BookForm

In this case, the model view ``BookView`` will use the form ``BookForm`` when
editing or creating model instances of ``Book``.

In some cases you may not implement a model view by yourself, which is why you
can also declare the default form used by a model view through the model itself:

.. code-block:: python

    from django.db import models
    from cubane.models import DateTimeBase

    class Book(DateTimeBase):
        class Meta:
            verbose_name        = 'Book'
            verbose_name_plural = 'Books'

        class Listing:
            columns = ['title', 'isbn']

        title = models.CharField(max_length=255)
        slug = models.SlugField(max_length=255, db_index=True)
        isbn = models.CharField(max_length=32, db_index=True, unique=True)

        @classmethod
        def get_form(cls):
            from forms import BookForm
            return BookForm

        def __unicode__(self):
            return self.title

The class method ``get_form`` should return the class of the form that is able
of represent instances of the model. A model view representing Books will then
determine the form by calling the very same class method on the model class,
unless a form has been declared by the model view itself.

.. seealso::

    Please refer to the :ref:`Model Forms <topics/backend/model_forms>` section
    in order to learn more about how model forms can be declared and customized
    for the backend system.




.. _topics/backend/model_view_filterform:

Model View Filter Form
======================

A model view may provide filter options by which records of a particular model
can be filtered by individual attributes. When working with books for example,
you may want to allow users of the backend system to filter books by specific
properties such as book title, author or ISBN.

A model filter form is used for this purpose. It is usually presented within a
side column which can be extended by the user to see all options available.

If no filter form is declared, then the regular model form is used instead,
which is sufficient in most cases. However, in some cases you may want to use a
quite different form or a separate form that extends the model form in a
specific way.

A filter form can be declared either by the model itself or by the
corresponding model view. For the later case, you can simply declare the filter
form in a similar way as the model form is declared:

.. code-block:: python

    from cubane.views import ModelView
    from models import Book
    from forms import BookForm

    class BookView(ModelView):
        template_path = 'cubane/backend/'
        model = Book
        form = BookForm
        filter_form = BookFilterForm

In this example, the ``BookForm`` is used when creating or editing books.
However, when filtering books, the ``BookFilterForm`` is used instead.

In some cases you may not implement a model view by yourself, which is why you
can declare a model filter form via the model in a similar way how you would
declare a model view:

.. code-block:: python

    from django.db import models
    from cubane.models import DateTimeBase

    class Book(DateTimeBase):
        class Meta:
            verbose_name        = 'Book'
            verbose_name_plural = 'Books'

        class Listing:
            columns = ['title', 'isbn']
            filter_by = ['title', slug', 'isbn']

        title = models.CharField(max_length=255)
        slug = models.SlugField(max_length=255, db_index=True)
        isbn = models.CharField(max_length=32, db_index=True, unique=True)

        @classmethod
        def get_form(cls):
            from forms import BookForm
            return BookForm

        @classmethod
        def get_filter_form(cls):
            from forms import BookFilterForm
            return BookFilterForm

        def __unicode__(self):
            return self.title

In this example, the ``BookForm`` is used for creating or editing instances of
books, but the ``BookFilterForm`` is used for filtering books instead, unless a
filter form has been declared by the corresponding model view directly.

.. note::

    Please note that ultimately the model listing option :listing:`filter_by`
    dictates the fields that are presented to users as part of the filter form,
    but those fields obviously need to be present in the form to begin with.

    You can read more about the the :listing:`filter_by` options as part of the
    :ref:`Model View Options <_topics/backend/model_view_options>` section.




.. _topics/backend/model_forms:

Model Forms
===========

For Cubane's backend system, a model form is a form that derives itself from
:class:`cubane.forms.BaseForm` or :class:`cubane.forms.BaseModelForm` and is
able to represent a model for the purpose of creating, editing or filtering
model instances.

The base class :class:`cubane.forms.BaseForm` derives itself from Django's
:class:`django.forms.Form` class but adds additional support for various aspects of
editing model instances and customizing the presentation and behavior of the
form.

When working with models, you would probably want to use the class
:class:`cubane.forms.BaseModelForm` instead, which derives itself from Django's
:class:`django.forms.ModelForm` and therefore provides the ability to generate
form fields based on the model automatically.

The ``BookForm`` from previous examples may be declared in the following way:

.. code-block:: python

    from cubane.forms import BaseModelForm
    from models import Books


    class BookForm(BaseModelForm):
        class Meta:
            model = Book
            fields = '__all__'




.. _topics/backend/model_view_options:

Model View Options
==================

Model view options are options declared on model level that alter the
presentation and functionality of the corresponding model view that operates on
the model as part of the backend system.

Let's say that the following model view is installed as part of the backend
system to manage ``Books``:

.. code-block:: python

    from cubane.backend.views import BackendSection
    from cubane.views import ModelView
    from models import Book

    class BookView(ModelView):
        template_path = 'cubane/backend/'
        model = Book

The first thing that you would want to customize is the columns that are
presented by the model view. By default, a model view will simply extract a
number of columns from the model automatically, which might not necessarily be
the ones you wanted to present.

In order to customize the columns presented, simply declare the class
``Listing`` within your model class and declare a list of columns:

.. code-block:: python

    from django.db import models
    from cubane.models import DateTimeBase

    class Book(DateTimeBase):
        class Meta:
            verbose_name        = 'Book'
            verbose_name_plural = 'Books'
            ordering            = ['title']

        class Listing:
            columns = [
                'title',
                'slug',
                'isbn',
                'recommended',
                'price'
            ]

        title = models.CharField(max_length=255)
        slug = models.SlugField(max_length=255, db_index=True)
        isbn = models.CharField(max_length=32, db_index=True, unique=True)
        published = models.DateField()
        publisher = models.CharField(max_length=255)
        author = models.CharField(max_length=255)
        recommended = models.BooleanField(default=False)
        price = models.DecimalField(max_digits=12, decimal_places=2)

        @classmethod
        def get_form(cls):
            from forms import BookForm
            return BookForm

        def __unicode__(self):
            return self.title

In the following, we will discuss various other ``Listing`` options that may
affect the presentation and functionality of a model view:

    - :listing:`columns`: List of visible columns.
    - :listing:`edit_columns`: List of editable columns.
    - :listing:`filter_by`: List of columns that can be filtered by.
    - :listing:`sortable`: True, if the model has a sequence order which can be
      changed.
    - :listing:`searchable`: List of additional columns that take part in quick
      searching.
    - :listing:`edit_view`: True, if bulk editing mode is available.
    - :listing:`grid_view`: True, if image-based grid view is available.
    - :listing:`default_view`: Default view type (``list``, ``edit`` or
      ``grid``).
    - :listing:`default_view`: Default view type (``list``, ``edit`` or
    - :listing:`data_import`: True, if data import is available.
    - :listing:`data_import`: True, if data export is available.
    - :listing:`data_columns`: List of columns that are exported.
    - :listing:`data_ignore`: List of columns that are not exported.
    - :listing:`data_map_fields`: Maps CSV file columns to internal columns
      when importing data.
    - :listing:`data_default_values`: Provides default values for columns
      during data import and export.
    - :listing:`data_id_field`: Specified an alternative primary key column
      when importing data.

The following sections will describe each individual listing option in more
detail:




.. listing:: columns

``columns``

    Declares a list of columns that are presented by the corresponding model
    view in default list mode.

    By default, the corresponding model view will extract a number of columns
    automatically if no columns have been declared.

    Any column reference must be the name of

        - a valid ``model field`` of the model or
        - an implicit method without arguments, like ``get_FOO_display()`` or
        - an explicit method without arguments, for example ``get_foo()`` or
        - a property of the model, for example ``foo``

    The maximum number of columns is restricted to *six* full columns. Any
    declared column is a full column, unless the column name is prefixed with
    ``/``, in which case the column is presented as a half-column. Half columns
    are not as wide as full columns and the system can present any combination
    of half and full columns as long as the total number of full columns does
    not exceed *six* columns. Two half columns would make up for one full
    column.

    For example:

    .. code-block:: python

        class Listing:
            columns = [
                'title',
                'slug',
                'isbn',
                'published',
                '/author',       # half column
                '/recommended',  # half column
                '/price'         # half column
            ]

    The column header label that is generated by the model view is
    automatically derived from the column reference name. For example, the
    column name ``title`` implicitly names the column ``Title``. You may
    declare the visual column label explicitly by piping the column name and the
    column label like in the following example:

    .. code-block:: python

        class Listing:
            columns = [
                'price|Total',
                ...
            ]

    The column value by default is left-aligned. However, you can align the
    column value to the right by prefixing the column name with a hyphen
    character (``-``):

    .. code-block:: python

        class Listing:
            columns = [
                '-price|Total',   # right-aligned
                ...
            ]

    For half-columns, the half-column indicator comes first, then the
    right-alignment indicator like the following example demonstrates:

    .. code-block:: python

        class Listing:
            columns = [
                '/-price|Total',   # right-aligned half column
                ...
            ]

    There are multiple formatting options available which can be expressed as
    another pipe expression. Cubane supports the following formatting options:

        - Boolean values presented as yes/no.
        - Url (clickable website url).
        - Currency.
        - HTML content.
        - Invoking listing action.

    The following example gives an overview of all formatting options based on
    our book example:

    .. code-block:: python

        class Listing:
            columns = [
                'get_absolute_url|Website|url',   # website url
                'html_excerpt|Excerpt|html',      # html content
                'recommended|Recommended|bool',   # yes/no
                '-price|Total|currency',          # right-aligned currency
                'action:checkout'                 # invoke action 'checkout'
            ]

    All columns that directly map to a model field are sortable by that column.
    For example the column declaration ``-price|Total|currency`` directly maps
    to the model field ``price``, therefore the user can sort the listing by the
    ``price`` column.

    If the column refers to a method or property, then sorting is disabled for
    such column. For example the column declaration
    ``get_absolute_url|Website|url`` invokes the instance method
    ``get_absolute_url`` for each instance, therefore the resulting value is
    computed and the resulting listing cannot be sorted by this column.

    To overcome this limitation, the name of the underlying property may be
    declared as well which can then be used to sort the resulting list of
    items. For example the column declaration
    ``slug(get_absolute_url)|Website|url`` is still invoking the instance
    method ``get_absolute_url`` for each instance but the resulting listing
    remains sortable by the ``Website`` column based on sorting the internal
    column ``slug`` which -- of course -- is the basis by which the full url is
    computed in the first place.

    A column declaration can also refer to foreign key fields.
    For example, let's say the book class had a foreign key to an ``Author`` model
    which contained a name field, then the author's name may be referenced in
    the listing by using the following column declaration:

    .. code-block:: python

        class Listing:
            columns = [
                'author__name|Author',   # name field in Author model
                ...
            ]

    .. note::

         The actual model view implementation may exclude certain columns to
         start with. Excluded columns will not be presented within the listing,
         even if the column is declared by the model.


.. listing:: edit_columns

``edit_columns``

    Declares a list of columns that are presented by the corresponding model
    view in bulk editing mode.

    By default, if no edit columns are declared, all regular columns declared
    via :listing:`columns` are used instead.

    .. code-block:: python

        class Listing:
            columns = [
                'title',
                'slug',
                'isbn',
                '/price'
            ]
            edit_view = True   # enable bulk-editing to begin with
            edit_columns = [   # slug not editable in bulk editing mode...
                'title',
                'isbn',
                '/price'
            ]

    If columns are declared, then only those columns are presented in bulk
    editing mode. The same rules for declaring regular columns via
    :listing:`columns` applies when declaring columns for bulk editing.

    .. note::

        Bulk editing must be enabled via the :listing:`edit_view` listing
        option in order to allow for bulk editing to begin with.

        Not all formatting options are available in bulk editing mode, since
        all column data is presented as form elements rather than formatted
        column values.

        Please refer to the :listing:`columns` section for more information on
        how to declare columns in general.


.. listing:: filter_by

``filter_by``

    Declares a list of columns that are presented within the side panel as
    filter options. By providing model fields as filter options, users of the
    backend system can precisely filter records by using specific values for
    individual columns.

    By default the filter panel is hidden away. Only if columns are declared
    via the ``filter_by`` option, the filter side panel is presented and
    available through the backend system.

    Each column must refer to a form field declared by the corresponding model
    form. This form is usually the same form that is used for editing records
    of the model through the backend system. An alternative form just for the
    purpose of filtering may be declared.

    Filter columns are declared via the ``filter_by`` option. For example, the
    following declaration will allow books to be filtered by **Title**,
    **Slug** and/or **ISDB number**; provided that the model form provides
    those three fields.

    .. code-block:: python

        class Listing:
            filter_by = [
                'title',
                'slug',
                'isbn'
            ]

    The resulting filter side panel form will present those columns in the order
    as specified: ``title`` then ``slug`` then ``isbn``. In particular for filter forms
    containing a number of fields, section titles can be inserted in order to provide
    a sense of partition or to group similar fields:

    .. code-block:: python

        class Listing:
            filter_by = [
                ':Book Title',       # section title
                'title',
                'slug',

                ':Identification',   # another section title
                'isbn'
            ]

    In the example above, the resulting filter form still contains three form
    fields, but will contain grouping information that combines the form fields
    ``title`` and ``slug`` into one local group (named ``Book Title``) and
    places the form field ``isbn`` into another logical group (named
    ``Identification``).

    .. note::

        The system may change the default presentation of form fields to suit
        the purpose of the filter form. For example: Usually boolean fields are
        represented as checkbox input fields within forms. However, the backend
        system will replace those with radio input fields for the purpose of
        filtering -- providing three possible options: Off, Yes (``True``) and
        No (``False``).


.. listing:: sortable

``sortable``

    Declares if a model is sortable in the backend.

    By default, a model is *not* sortable.

    When making a model sortable, the backend system will provide user
    interface options to define the order or items by allowing users to drag 'n
    drop items. The established sorting order can then be used for example to
    derive the order in which items are presented on the frontend.

    If sortable is set to ''True'', then the system implicitly expects that the
    model has a column with the name ''seq' of some integer type, for example:

    .. code-block:: python

        from django.db import models
        from cubane.models import DateTimeBase

        class Book(DateTimeBase):
            class Listing:
                sortable = True

            title = models.CharField(max_length=255)
            slug = models.SlugField(max_length=255, db_index=True)
            isbn = models.CharField(max_length=32, db_index=True, unique=True)
            seq = models.IntegerField(db_index=True, default=0, editable=False)

    In this case, the model declares a field with the name ''seq'' which is
    used by the system to store the order of books. The first book within a
    sequence will start with 1, the second book with 2 and so forth. Backend
    users can use drag 'n drop in order to manipulate the order in which books
    are ordered.

    On the frontend, you would usually sort books by ordering them by the
    ''seq'' field; for example to present a list of books in a specific
    user-defined order.

    .. code-block:: python

        books = Book.objects.all().order_by('seq')

    The sequence of items is only defined per level of hierarchy in case
    folders are used. For example, if books were organized within folders -
    let's say genres - then the sequence order as defined by the ''seq'' field
    applies for each genre individually. Horror books declare a sequence
    starting with 1 while books in the kids section also start with 1. The
    backend system will distinguish those cases and will not allow users to
    change the order in case books of multiple genres are presented at the same
    time.


.. listing:: searchable

``searchable``

    Declares a list of additional model fields by which model instances are
    searched when using the quick search facility.

    By default, no additional model fields are declared as being searchable.

    When searching via the quick search method, all visible columns as declared
    via the :listing:`columns` field are searchable. Further, quick search only
    applies to text-related field and would not apply to boolean fields for
    example.

    Sometimes, you would like to allow the quick search facility to yield
    results based on columns that are to directly presented within the listing
    screen of the backend. In this case those *additional* columns may be
    declared via the :listing:`searchable` listing option.

    For example, if the IDBN number for books would not be part of the listing
    for some reason, but you still wanted users to be able to search via the
    IDBN number in the backend, then you could declare the following listing
    option:

    .. code-block:: python

        class Listing:
            searchable = ['isbn']

    .. note::

        Non-text fields and fields that are already listed as columns via the
        :listing:`columns` listing option are ignored.


.. listing:: edit_view

``edit_view``

    Declares if bulk-editing is provided for the listing screen.

    By default bulk editing is not enabled.

    Cubane's backend system provides bulk editing functionality, where certain
    columns can be edited at the same time on the listing screen; rather than
    opening each item for editing individually.

    This options is not enabled by default and may require the definition of
    columns that are applicable in bulk editing mode (see section
    :listing:`edit_columns`).


.. listing:: grid_view

``grid_view``

    Declares if the image-based grid view is provided for the listing screen.

    By default, grid view is not available.

    For some type of items, in particular for those that have an image
    associated with it, Cubane's backend system can present items as image
    thumbnails rather than tabular data. In particular for media assets this
    type of presentation is more useful.

    The system will implicitly assume that each item is a
    :class:`cubane.media.models.Media` instance or has a foreign key to a
    :class:`~cubane.media.models.Media` instance called ``image``.

    If you model does not have an image reference or the field is called
    differently, you can either rename your field or introduce a property with
    the name ``image`` that returns the reference to
    :class:`~cubane.media.models.Media` internally.

    .. code-block:: python

        class Listing:
            grid_view = True


.. listing:: default_view

``default_view``

    Declares the default view that is presented for the corresponding model
    within Cubane's backend system.

    By default the regular list view is presented, which is always available
    for any model:

    .. code-block:: python

        class Listing:
            default_view = 'grid'

    Available options are:

        +------------------+----------------------------------------------------+
        | Option           | Description                                        |
        +==================+====================================================+
        | ``list``         | Default list view (tabular)                        |
        +------------------+----------------------------------------------------+
        | ``compact-list`` | Compact version of the default list view (tabular) |
        +------------------+----------------------------------------------------+
        | ``edit``         | Bulk editing view                                  |
        +------------------+----------------------------------------------------+
        | ``grid``         | Image-based grid view                              |
        +------------------+----------------------------------------------------+


.. listing:: data_import

``data_import``

    Declares whether CSV file data import is available or not.

    By default, CSV data import is *not* available.

    When importing CSV files, the first row must contain the name of the model
    field the column data represents and the model form must contain a valid
    form field of the same name.

    During import, each data record is then processed via the model form as if
    the data were inputted into the form manually.

    .. code-block:: python

        class Listing:
            data_import = True

    .. note::

        If the import data contains the primary key field, then the
        corresponding record is updated; otherwise a new record is created.


.. listing:: data_export

``data_export``

    Declares whether CSV file data export is available or not.

    By default, CSV data export is *not* available.

    When exporting CSV files, the system will export all field columns, unless
    specific columns are declared via the :listing:`data_columns` listing option.

    .. code-block:: python

        class Listing:
            data_export = True

    .. note::

        The system will automatically export model field names as the first
        data row that is exported.


.. listing:: data_columns

``data_columns``

    Declares a list of columns that are exported when using the CSV file export
    option (which must be enabled via :listing:`data_export`).

    By default, the list of exported columns is undefined and the exporter will
    export all model columns that are defined by the model automatically, unless
    columns are ignored for data export via :listing:`data_ignore`.

    .. code-block:: python

        class Listing:
            data_export = True
            data_columns = [
                'id',
                'title',
                'slug',
                'isbn'
            ]


.. listing:: data_ignore

``data_ignore``

    Declares a list of columns that are ignored when export CSV files. Listed
    columns are *not* exported, even if they are declared via
    :listing:`data_columns`.

    By default, no columns are ignored.

    .. code-block:: python

        class Listing:
            data_export = True
            data_ignore = [
                'isbn'   # do not export ISBN
            ]

    .. note::

        :listing:`data_ignore` is ideally suited to declare fields you do not
        want to be exported if no list of columns has been declared via
        :listing:`data_columns`. In this case, all columns are exported and you
        can use :listing:`data_ignore` to remove unwanted ones.


.. listing:: data_map_fields

``data_map_fields``

    Declares a mapping from alternative column names to actual model field
    names used during the CSV file import process to understand
    differently-named columns.

    By default, no additional data mapping is declared and the CSV file importer
    will only understand column names that match the model.

    .. code-block:: python

        class Listing:
            data_export = True
            data_map_fields = {
                'IDBN Number': 'isbn',
                ...
            }

    The example demonstrates how an additional column name ``IDBN Number`` may
    be declared in order to map the column ``ISBN Number`` to the internal
    model field ``isbn``. Without such mapping, the column name must have been
    labeled as ``isbn`` in order for the importer to be able to import the data
    successfully.

    .. note::

        Mapping columns in this way is particularly useful if you renamed
        columns and would still be able to support the previous name or the
        input data is part of an initial data import process and has been
        compiled by hand with column labels that do not necessarily match the
        ones used by the model.


.. listing:: data_default_values

``data_default_values``

    Declares a default value that is used when importing data from a CSV file
    and a particular column cell value happens to be empty.

    By default, the default value for an empty cell value is ``None``, unless
    :listing:`data_default_value` declares a different value.

    .. code-block:: python

        class Listing:
            data_export = True
            data_default_values = {
                'title': '<Unnamed>',
                ...
            }

    The example demonstrates how a book title will automatically take the value
    ``<Unnamed>`` in case a book title is not defined within the CSV import
    file.

    .. note::

        Even though the default value is ``None``, the actual value that is
        used by the model may also depend on the model form that is used by the
        data importer to validate each record. Further, the model itself may
        declare a default value on the database level.

        The listing option :listing:`data_default_values` sets a default value
        as part of the import process before the data is validated via the form
        or saved to the database.


.. listing:: data_id_field

``data_id_field``

    Declares the name of the column that is used as the primary key for each
    record in order for the data importer to decide if any given record already
    exists in the system and is therefore considered to be an update operation
    rather than an insert operation.

    By default, the name of the primary key column is the name of the primary
    key of the model, which is typically ``id`` but does not have to be.

    .. code-block:: python

        class Listing:
            data_export = True
            data_id_field = 'isbn'

    The example above shows how books are mapped to all existing books in the
    system when importing CSV data from a file. By default, the system would
    have used the ``id`` primary key column of the model for this purpose, but
    perhaps we do not want to include the *build-in* ``id`` column in the first
    place. By declaring the ``isbn`` column as the primary key, any existing
    records from the CSV file with the same ``isbn`` number will trigger a data
    update rather than an insert.

    .. note::

        Make sure that the column that has been declared as the primary key for
        the purpose of importing data from a CSV file is unique. There should
        not be more than one record with the same column value.




.. _topics/backend/model_view_overrides:

Model View Overrides
====================
